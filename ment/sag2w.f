C	THE FOLLOWING SAG2-PACKAGE HAS BEEN WRITTEN BY U.ROHRER (SIN)
C	THIS IS A SUBROUTINE PACKAGE, CONTAINING ROUTINES TO
C	SIMULATE ADVANCED GRAPHING II FOR MENT2A. INSTEAD OF TCS-CALLS
C	SOME BASIC SINAC-GRAPHX CALLS ARE USED (U. ROHRER, AUG.1985)
C	IMPROVED BY URS ROHRER, JULY 1988
C	REDONE FOR UIS WORKSTATION GRAPHICS BY URS ROHRER (PSI), OCT. 1990
C
	SUBROUTINE BINITT
C
C	SETS THE INITIAL VALUES IN COMMON
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
	COMMON /SCAL/ XSCAL,YSCAL,XMIN,YMIN,XMAX,YMAX
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
	COMMON /LOGLIN/ LX,LY
	COMMON /TEXT1/ IM
	COMMON /DASH/ MD
	COMMON / TEKT / MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	REAL            MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
C
	IFRE= 1
	IM  = 0
	ITX = 3
	ITY = 4
	IDX = 5
	IDY = 5
	NCX = 1
	NCY = 1
	LX  = 1
	LY  = 1
	MD  = 1
	RETURN
	END
C
	SUBROUTINE NPTS(K)
C
C	SETS THE NUMBER OF DATA POINTS TO BE PLOTTED
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	N = K
	RETURN
	END
C
	SUBROUTINE SLIMX(XMIN,XMAX)
C
C	SETS THE SCREEN MINIMUM AND MAXIMUM FOR THE X-AXIS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	XA = XMIN
	XE = XMAX
	RETURN
	END
C
	SUBROUTINE SLIMY(YMIN,YMAX)
C
C	SETS THE SCREEN MINIMUM AND MAXIMUM FOR THE Y-AXIS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	YA = YMIN
	YE = YMAX
	RETURN
	END
C
	SUBROUTINE XTYPE(IT)
C
C	LINEAR OR LOG SCALE IN X (2 FOR LOG)
C
	COMMON /LOGLIN/ LX,LY
C
	LX = IT
	RETURN
	END
C
	SUBROUTINE YTYPE(IT)
C
C	LINEAR OR LOG SCALE IN Y (2 FOR LOG)
C
	COMMON /LOGLIN/ LX,LY
 
	LY = IT
	RETURN
	END
C
	SUBROUTINE LINE(L)
C
C	SPECIFIES THE LINE TYPE TO BE DRAWN BETWEEN DATA POINTS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	ILT = L
	RETURN
	END
C
	SUBROUTINE LINAX(L)
C
C	SPECIFIES THE LINE TYPE TO BE DRAWN FOR AXIS GRID
C
	COMMON /DASH/ MD
	MD = L
	RETURN
	END
C
	SUBROUTINE SYMBL(IS)
C
C	DESIGNATES THE SYMBOL AT THE DATA POINTS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	ISYM = IS
	RETURN
	END
C
	SUBROUTINE STEPS(K)
C
C	DESIGNATES THE INCREMENT BETWEEN DATA POINT SYMBOLS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
C
	IFRE = K
	RETURN
	END
C
	SUBROUTINE STEPL(K)
C
C	INACTIVE
C
	RETURN
	END
C
	SUBROUTINE SIZES(K)
C
C	INACTIVE
C
	RETURN
	END
C
	SUBROUTINE XTICS(IT)
C
C	SETS THE NUMBER OF VERTICAL GRID BARS ALONG THE X-AXIS
C
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
C
	ITX = IT
	RETURN
	END
C
	SUBROUTINE YTICS(IT)
C
C	SETS THE NUMBER OF HORIZONTAL GRID BARS ALONG THE Y-AXIS
C
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
C
	ITY = IT
	RETURN
	END
C
	SUBROUTINE XDEN(ID)
C
C	SETS THE DENSITY OF TIC MARKS ALONG THE X-AXIS
C
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
C
	IDX = ID
	RETURN
	END
C
	SUBROUTINE YDEN(ID)
C
C	SETS THE DENSITY OF TIC MARKS ALONG THE Y-AXIS
C
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
C
	IDY = ID
	RETURN
	END
C
	SUBROUTINE CPLOT(X,Y)
C
C	PLOTS A CURVE, DOES NOT DRAW THE GRID
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
	COMMON /SCAL/ XSCAL,YSCAL,XMIN,YMIN,XMAX,YMAX
	COMMON /LOGLIN/ LX,LY
	COMMON /TEXT1/ IM
	COMMON /OLD/ KLT
	COMMON / TEKT / MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	REAL            MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	DIMENSION X(1),Y(1)
c	DATA IM /0/
C
	IF (IFRE .EQ. 0) IFRE = 10000
C
C	DRAW THE CURVE (ILT .LT. 0 NO CURVE)
C
	IF (ILT .GE. 0) THEN
	 DO J = 1, N
	  XP = XA + XSCAL * (X(J) - XMIN)
	   IF (LX .EQ. 2) XP = XA + XSCAL*(LOG10(X(J))-LOG10(XMIN))
	  YP = YA + YSCAL * (Y(J) - YMIN)
	   IF (LY .EQ. 2) YP = YA + YSCAL*(LOG10(Y(J))-LOG10(YMIN))
	   IF (J .EQ. 1) THEN
	    CALL GRAMOV(XP*SCALX,YP*SCALY)
	   ELSE
	    CALL GRADRW(XP*SCALX,YP*SCALY)
	   ENDIF
	 ENDDO
	ENDIF
C
C	DRAW POINTS WITH INCREMENT IFRE (ISYM .EQ. 0 --> NO POINTS)
C
	IF (ISYM .NE. 0) THEN
	 DO J = 1, N
	 IM = IM + 1
	  IF (MOD(IM, IFRE) .EQ. 0) THEN
	   XP = XA + XSCAL * (X(J) - XMIN)
	    IF (LX .EQ. 2) XP = XA + XSCAL*(LOG10(X(J))-LOG10(XMIN))
	   YP = YA + YSCAL * (Y(J) - YMIN)
	    IF (LY .EQ. 2) YP = YA + YSCAL*(LOG10(Y(J))-LOG10(YMIN))
C
C	   DRAW "X"
C
	   IF (ISYM .EQ. 2) THEN
	    CALL GRAMOV(SCALX*(XP-.12),SCALY*(YP+.12))
	    CALL GRADRW(SCALX*(XP+.12),SCALY*(YP-.12))
	    CALL GRAMOV(SCALX*(XP+.12),SCALY*(YP+.12))
	    CALL GRADRW(SCALX*(XP-.12),SCALY*(YP-.12))
C
C	   DRAW SQUARE
C
	   ELSE IF (ISYM .EQ. 4) THEN
	    CALL GRAMOV(SCALX*(XP-.12),SCALY*(YP-.12))
	    CALL GRADRW(SCALX*(XP+.12),SCALY*(YP-.12))
	    CALL GRADRW(SCALX*(XP+.12),SCALY*(YP+.12))
	    CALL GRADRW(SCALX*(XP-.12),SCALY*(YP+.12))
	    CALL GRADRW(SCALX*(XP-.12),SCALY*(YP-.12))
C
C	   DRAW "+"
C
	   ELSE IF (ISYM .EQ. 8) THEN
	    CALL GRAMOV(SCALX*XP,SCALY*(YP-.12))
	    CALL GRADRW(SCALX*XP,SCALY*(YP+.12))
	    CALL GRAMOV(SCALX*(XP-.12),SCALY*YP)
	    CALL GRADRW(SCALX*(XP+.12),SCALY*YP)
C
C	   DRAW ADE-CHARACTER
C
	   ELSE
	    CALL TEXT_OUT(CHAR(ISYM)//CHAR(0),XP*SCALX,YP*SCALY,0)
	   ENDIF
	  ENDIF
	 ENDDO
	ENDIF
C
	KLT = ILT
	RETURN
	END
C
	SUBROUTINE CHECK(X,Y)
C
C	DOES THE AUTO SCALING AND CALCULATES GRID PARAMETERS
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
	COMMON /SCAL/ XSCAL,YSCAL,XMIN,YMIN,XMAX,YMAX
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
	COMMON /LOGLIN/ LX,LY
	DIMENSION X(1),Y(1)
	DIMENSION IT(33),ID(33)
	DATA IT /2,3,4,5,6,4,8,5,4,6,12,7,14,8,6,5,18,7,20,5
     x          ,8,12,24,5,6,14,10,8,30,11,32,9,12/
	DATA ID /10,5,5,2,2,2,2,2,3,2,1,2,1,2,3,4,1,3,1,5
     x        ,3,2,1,6,5,2,3,4,1,3,1,4,3/
C
C	FIND MINIMUM AND MAXIMUM OF X AND Y ARRAYS
C
	XMAX = X(1)
	YMAX = Y(1)
	XMIN = X(1)
	YMIN = Y(1)
	DO I = 1, N
	 IF (X(I) .GT. XMAX) XMAX = X(I)
	 IF (Y(I) .GT. YMAX) YMAX = Y(I)
	 IF (X(I) .LT. XMIN) XMIN = X(I)
	 IF (Y(I) .LT. YMIN) YMIN = Y(I)
	ENDDO
C
	ENTRY CHECK2(X,Y)
C
C	CALCULATE ROUNDING MAGNITUDE
C
	CALL RMAG(XMAX,XMIN,NX)
	CALL RMAG(YMAX,YMIN,NY)
C
C	ROUND MINIMUMS AND MAXIMUMS (SPECIAL FOR LOG-SCALE)
C
	IF (LX .NE. 2) THEN
	 CALL RMAXLIN(XMAX,NX,XMAX,K1)
	 CALL RMINLIN(XMIN,NX,XMIN,K2)
	ELSE
	 CALL RMAXLOG(XMAX,XMAX,N1)
	 CALL RMINLOG(XMIN,XMIN,N2)
	ENDIF
C
	IF (LY .NE. 2) THEN
	 CALL RMAXLIN(YMAX,NY,YMAX,K3)
	 CALL RMINLIN(YMIN,NY,YMIN,K4)
	ELSE
	 CALL RMAXLOG(YMAX,YMAX,N3)
	 CALL RMINLOG(YMIN,YMIN,N4)
	ENDIF
C
C
C	CALCULATE SCALING FACTORS
C
	XSCAL = (XE-XA) / (XMAX-XMIN)
	 IF (LX .EQ. 2) XSCAL = (XE-XA) / FLOAT(N1-N2)
	YSCAL = (YE-YA) / (YMAX-YMIN)
	 IF (LY .EQ. 2) YSCAL = (YE-YA) / FLOAT(N3-N4)
C
C	ESTABLISH NUMBER OF GRID MARKS
C
	IH  = K1 - K2
	IV  = K3 - K4
	ITX = IT(IH)
	ITY = IT(IV)
	IF (LX .EQ. 2) ITX = N1 - N2 + 1
	IF (LY .EQ. 2) ITY = N3 - N4 + 1
C
C	ESTABLISH DENSITY OF TIC MARKS
C
	IDX = ID(IH)
	IDY = ID(IV)
	IF (LX .EQ. 2) IDX = 10
	IF (LY. EQ. 2) IDY = 10
C
C	ESTABLISH NUMBER OF DIGITS AFTER THE DECIMAL POINT FOR LABELS
C
	NCX = NX
	NCY = NY
	IF (NX .LE. 0) NCX = -1
	IF (NY .LE. 0) NCY = -1
C
C	ESTABLISH NUMBER OF CHARACTERS OF THE LABEL
C
	MCX = IABS(NX) + 3
	MCY = IABS(NY) + 3
	RETURN
	END
C
	SUBROUTINE DSPLAY(X,Y)
C
C	DISPLAYS THE COMPLETE GRAPH ON THE SCREEN
C
	COMMON /GRAPH/ N,XA,XE,YA,YE,ILT,ISYM,IFRE
	COMMON /SCAL/ XSCAL,YSCAL,XMIN,YMIN,XMAX,YMAX
	COMMON /AXIS/ ITX,ITY,IDX,IDY,NCX,NCY,MCX,MCY
	COMMON /LOGLIN/ LX,LY
	COMMON /DASH/ MD
	COMMON / TEKT / MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	REAL            MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	DIMENSION X(1),Y(1)
C
	XS = 0.78 * LCHX * 1.2
	YS = 0.78 * LCHX
C
C	DRAW CURVE
C
	CALL CPLOT(X,Y)
c	CALL FLUSH_UIS
	CALL FLUSH_XWI
	CALL LINEX(1)
	CALL SET_COL(3)	!	GRUEN
C
C	VERTICAL BARS OF THE GRID
C
	XT = (XE-XA) / FLOAT(ITX-1)
	K = ITX / 7 + 1
	DO I = 1, ITX
	 IF (K*((I+K-1)/K)-I-K+1.EQ.0 .OR. I.EQ.ITX) THEN
	  CALL GRAMOV((XA+FLOAT(I-1)*XT)*SCALX,YA*SCALY)
	  CALL GRADRW((XA+FLOAT(I-1)*XT)*SCALX,YE*SCALY)
	 ENDIF
	ENDDO
C
C	HORIZONTAL BARS OF THE GRID
C
	YT = (YE-YA) / FLOAT(ITY-1)
	K = ITY / 7 + 1
	DO I = 1, ITY
	 IF (K*((I+K-1)/K)-I-K+1.EQ.0 .OR. I.EQ.ITY) THEN
	  CALL GRAMOV(XA*SCALX,(YA+FLOAT(I-1)*YT)*SCALY)
	  CALL GRADRW(XE*SCALX,(YA+FLOAT(I-1)*YT)*SCALY)
	 ENDIF
	ENDDO
c	CALL FLUSH_UIS
	CALL FLUSH_XWI
	CALL LINEX(0)
C
	XINC = (XMAX-XMIN) / FLOAT(ITX-1)
	YINC = (YMAX-YMIN) / FLOAT(ITY-1)
C
C	LABELS FOR THE HORIZONTAL AXIS
C
	K = ITX / 7 + 1
	DO I = 1, ITX
	 XOUT = XMIN + FLOAT(I-1) * XINC
	  IF (LX .EQ. 2) XOUT = XMIN * .32**FLOAT(I-1)
C
C	RECALCULATE NUMBER OF DIGITS AFTER DECIMAL POINT FOR LOG-SCALE
C
	 IF (LX .EQ .2) THEN
	  XX = LOG10(XOUT)
	   IF (XX .EQ. 0.0) XX = .1
	  IND = NINT(XX)
	  NCX = -IND
	   IF (IND .EQ. 0) NCX = 1
	   IF (IND .GT. 0) NCX = -1
	  MCX = IND + 1
	   IF (IND .EQ. 0) MCX = 3
	   IF (IND .LT. 0) MCX =IABS(IND) + 2
	 ENDIF
C
	 IF(K*((I+K-1)/K)-I-K+1 .EQ. 0) THEN
	  XXX = XA + FLOAT(I-1) * XT
	  IF (I .EQ. ITX) THEN
	   XXX = XXX  - FLOAT(MCX) * .625 * LCHX *.9 
	  ELSE
	   XXX = XXX  - FLOAT(MCX) * .312 * LCHX *.9
	  ENDIF
	  CALL RENOUT(XOUT,NCX,MCX,XXX,YA-1.66*LCHY*1.1)
	 ENDIF
	ENDDO
C
C	LABELS FOR THE VERTICAL AXIS
C
	K = ITY / 7 + 1
	DO I = 1, ITY
	 YOUT = YMIN + FLOAT(I-1) * YINC
	  IF (LY .EQ. 2) YOUT = YMIN * 10.**FLOAT(I-1)
C
C	RECALCULATE NUMBER OF DIGITS AFTER DECIMAL POINT FOR LOG-SCALE
C
	 IF (LY .EQ. 2) THEN
	  YY = LOG10(YOUT)
	   IF (YY .EQ. 0.0) YY = .1
	  IND = NINT(YY)
	  NCY = -IND
	   IF (IND .EQ. 0) NCY = 1
	   IF (IND .GT. 0) NCY = -1
	  MCY = IND + 1
	   IF (IND .EQ. 0) MCY = 3
	   IF (IND .LT. 0) MCY = IABS(IND) + 2
	 ENDIF
C
	 IF(K*((I+K-1)/K)-I-K+1 .EQ. 0) THEN
	  XXX = XA - (3.5 + FLOAT(MCY)) * XS
	  CALL RENOUT(YOUT,NCY,MCY,XXX,YA + FLOAT(I-1)*YT)
	 ENDIF
	ENDDO
C
C	TICS FOR THE HORIZONTAL AXIS
C
	IF (LX .NE. 2) THEN
	 DO I = 1, 1+IDX*(ITX-1)
	  CALL GRAMOV((XA+FLOAT(I-1)*XT/FLOAT(IDX))*SCALX,(YA-YS)*SCALY)
	  CALL GRADRW((XA+FLOAT(I-1)*XT/FLOAT(IDX))*SCALX,YA*SCALY)
	 ENDDO
	ELSE
	 DO I = 1, ITX-1
	  DO J = 1, IDX
	   CALL GRAMOV((XA+FLOAT(I-1)*XT+LOG10(FLOAT(J))*XT)*SCALX,
     *                 (YA-YS)*SCALY)
	   CALL GRADRW((XA+FLOAT(I-1)*XT+LOG10(FLOAT(J))*XT)*SCALX,
     *                  YA*SCALY)
	  ENDDO
	 ENDDO
	ENDIF
C
C	TICS FOR THE VERTICAL AXIS
C
	IF (LY .NE. 2) THEN
	 DO I = 1, 1 + IDY * (ITY-1)
	  CALL GRAMOV((XA-XS)*SCALX,(YA+FLOAT(I-1)*YT/FLOAT(IDY))*SCALY)
	  CALL GRADRW(XA*SCALX,(YA+FLOAT(I-1)*YT/FLOAT(IDY))*SCALY)
	 ENDDO
	ELSE
   61	 DO I = 1, ITY - 1
	  DO J = 1, IDY
	   CALL GRAMOV((XA-XS)*SCALX,
     *          (YA+FLOAT(I-1)*YT+LOG10(FLOAT(J))*YT)*SCALY)
	   CALL GRADRW(XA*SCALX,
     *          (YA+FLOAT(I-1)*YT+LOG10(FLOAT(J))*YT)*SCALY)
	  ENDDO
	 ENDDO
	ENDIF
	RETURN
	END
C
	SUBROUTINE RENOUT(RN,INDK,NCH,X,Y)
C
C	OUTPUT REAL NUMBER STARTING AT POSITION (X/Y = LOWER LEFT CORNER)
C
	COMMON / TEKT / MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	REAL            MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	CHARACTER*20 WORD
	CHARACTER*10 FORM1, FORM2
	DATA FORM1 /'(F9.1)'/
	DATA FORM2 /'(I9)'/
C
	IF (INDK .GE. 0) THEN
	 WRITE(FORM1(3:3),1000) NCH
	 WRITE(FORM1(5:5),1001) INDK
1000	 FORMAT(I1)
	 WRITE(WORD(1:NCH),FORM1) RN
         WORD(NCH+1:NCH+1) = CHAR(0)
	ELSE
	 WRITE(FORM2(3:3),1001) NCH
1001	 FORMAT(I1)
	 WRITE(WORD(1:NCH),FORM2) NINT(RN)
         WORD(NCH+1:NCH+1) = CHAR(0)
	ENDIF
	IF (RN .GE. 0.0) THEN
	 XP = X + LCHX		! COMPENSATION FOR MINUS SIGN
	ELSE
	 XP = X
	ENDIF
C
C	SUPPRESS LEADING BLANKS LIKE IN GRAPHX
C
	DO 10 J = 1, NCH
	 IF (WORD(J:J) .NE. ' ') GO TO 20
10	CONTINUE
20	CONTINUE
	CALL TEXT_OUT(WORD(J:NCH)//char(0),XP*SCALX,Y*SCALY,
     X                INT(10.*LCHX)-1)
	RETURN
	END
C
C	THE FOLLOWING 5 SUBROUTINES SERVE AS AUXILIARY ROUTINES
C	FOR THE SUBROUTINE CHECK DOING AUTOSCALING
C
	SUBROUTINE RMAG(XMAX,XMIN,N)
C
	REL = XMAX - XMIN
	X = - LOG10(REL)
	 IF (X .GE. 0.0) N = IFIX(X+.5)+1
	 IF (X .LT. 0.0) N = IFIX(X-.5)+1
	RETURN
	END
C
	SUBROUTINE RMAXLIN(XIN,N,XOUT,K)
C
	Y = ABS(XIN)
	Y = Y * 10.**N
	K = Y
	 IF (Y-FLOAT(K) .LT. 0.0001) GO TO 10
	 IF (XIN .GT. 0.0) K = K + 1
   10	X = FLOAT(K) / 10.**N
	IF (XIN .LT. 0.0) X = -X
	IF (XIN .LT. 0.0) K = -K
	XOUT = X
	RETURN
	END
C
	SUBROUTINE RMINLIN(XIN,N,XOUT,K)
C
	Y = ABS(XIN)
	Y = Y * 10.**N
	K = Y
	 IF (Y-FLOAT(K) .LT. 0.0001) GO TO 10
	 IF (XIN .LT. 0.0) K = K + 1
   10	X = FLOAT(K) / 10.**N
	 IF (XIN .LT. 0.0) X = -X
	 IF (XIN .LT. 0.0) K = -K
	XOUT = X
	RETURN
	END
C
	SUBROUTINE RMAXLOG(XIN,XOUT,N)
C
	X = LOG10(XIN)
	N = IFIX(X)
	 IF (ABS(X-FLOAT(N)) .LT. 0.0001) GO TO 10
	 IF (X .GT. 0.0) N = N + 1
   10	XOUT = 10.**N
	RETURN
	END
C
	SUBROUTINE RMINLOG(XIN,XOUT,N)
C
	X = LOG10(XIN)
	N = IFIX(X)
	 IF (ABS(X-FLOAT(N)) .LT. 0.0001) GO TO 10
	 IF (X .LT. 0.0) N = N - 1
   10	XOUT = 10.**N
	RETURN
	END
C
	SUBROUTINE TIMDS(X,Y)
C
C	DISPLAY DATE AND TIME AT LOWER LEFT POSITION (X,Y = LOWER LEFT CORNER)
C
	COMMON / TEKT / MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	REAL            MINX,MAXX,MINY,MAXY,LCHX,LCHY,SCALX,SCALY
	COMMON /TIMDSP/ ITDFLAG
C
C       TIM and DAT are zero terminated, 1 char longer !!!!
C
        CHARACTER TIM*9, DAT*10

        CALL MYTIME(TIM)
        CALL MYDATE(DAT)
C
	N = 1
	IF (DAT(1:1) .EQ. ' ') N = 2
	CALL TEXT_OUT(DAT(N:9),X*SCALX,(Y+LCHY)*SCALY,INT(10.*LCHX)-1)
	CALL TEXT_OUT(TIM,X*SCALX,Y*SCALY,INT(10.*LCHX)-1)
C
	RETURN
	END

	subroutine trim(source,dest,length)
c
c	copies source to destination. leading blanks are omitted.
c
	character*(*) source, dest
c
	leng = len(source)
	do ibeg = 1, leng
	 if (source(ibeg:ibeg) .ne. ' ') then
	  i = 1
	  do j = ibeg, leng
	   dest(i:i) = source(j:j)
	   i = i + 1
	  enddo
	  length = leng - ibeg + 1
	  return
	 endif
	enddo 
10	continue
c
	end
