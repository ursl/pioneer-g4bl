C**********************************************************************
C
C CURRICULUM VITAE OF THE CODE:
C =============================
C
C MENT2A IS A TWO-DIMENSIONAL COMPUTED TOMOGRAPHY CODE WHICH
C RECONSTRUCTS THE TRANSVERSE EMITTANCE DISTRIBUTION OF AN
C ACCELERATOR BEAM.
C IT PRODUCES THE RECONSTRUCTION WITH THE LARGEST ENTROPY.
C THE ALGORITHM IS DESCRIBED IN THE FOLLOWING REFERENCES:
C
C          G. MINERBO, "MENT: A MAXIMUM ENTROPY ALGORITHM FOR
C          RECONSTRUCTING A SOURCE FROM PROJECTION DATA," COMPUTER
C          GRAPHICS AND IMAGE PROCESSING 10, 48-68 (1979)
C
C          O. R. SANDER, G. N. MINERBO, R. A. JAMESON AND D. D.
C          CHAMBERLIN, "BEAM TOMOGRAPHY IN TWO AND FOUR DIMENSIONS,"
C          PROC. 1979 LINEAR ACCELERATOR CONFERENCE, REPORT BNL-51134,
C          BROOKHAVEN NAT. LAB., UPTON, NY, 1980, PAGES 314-318.
C
C MODIFICATION HISTORY:
C =====================
C
C INITIAL VERSION OF THE CODE USED THE TEKTRONIX PLOT10 GRAPHICS (AD-
C VANCED GRAPHING II) AND WAS WRITTEN FOR THE CDC FTN COMPILER.
C CODE SENT TO W.JOHO (SIN) BY G.MINERBO (LOS ALAMOS) MARCH 5, 1981.
C THIS VERSION IS ADAPTED FOR THE VAX-VMS SYSTEM. ( U. ROHRER, SIN. 1981-1982 )
C THE NECESSARY ADVANCED GRAPHING II CALLS ARE SIMULATED (SAG2-PACKAGE)
C BASIC GRAPHIC-CALLS TAKEN FROM SINAC-LIBRARY (U. ROHRER, AUG. 1985)
C OVERVIEW COLLECTION ADDED BY U. ROHRER, JULY 1988
C MODIFIED FOR DEC-UIS WORKSTATION GRAPHIC SYSTEM BY U. ROHRER, ???? 
C MODIFIED FOR X-WINDOWS GRAPHIC SYSTEM UNDER VAX-VMS BY U. ROHRER, ????
C PORTED TO LINUX WITH X-WINDOWS BY U. ROHRER (PSI), JUNE 1995
C
C**********************************************************************
C
C KEY TO FORTRAN ROUTINES
C
C SETP    DEFINES INPUT QUANTITIES FOR TEST PROBLEMS.  NOT USED FOR
C         RECONSTRUCTIONS FROM MEASURED DATA.
C
C PREP    PREPOCESSING OF INPUT DATA.  MAKES PROJECTION DATA
C         NON-NEGATIVE, RENORMALIZES DATA, IF KADJ.NE.0, ADJUSTS
C         REGISTRATION OF PROFILES TO PRODUCE CONSISTENT CENTROID.
C
C MENT    ITERATIVE RECONSTRUCTION ALGORITHM.  USES QUADRATURE ROUTINES
C         QTRAP WHICH CALL EXTERNAL FUNCTION PROD.  COMPUTES
C         VALUES IN SOURCE ARRAY AFTER COMPLETING ITERATIONS.
C
C PROD    COMPUTES PRODUCT OF HFAC FACTORS.  CALLED BY QUADRATURE
C         ROUTINES QTRAP.  CALLS HINT.
C
C HINT    INTERPOLATES ON VALUES IN HFAC ARRAY.
C
C SPLOT   PRODUCES PLOTS OF PROJ, HFAC, AND CONTOUR OR ISOMETRIC PLOTS
C         OF THE RECONSTRUCTION IN THE SOURCE ARRAY.
C
C SOFUN   COMPUTES VALUE OF 2-D EMITTANCE FUNCTION.  USED ONLY FOR TEST
C         PROBLEMS.  USER MAY ADD OPTIONS HERE FOR NEW TEST PROBLEMS.
C
C QTRAP   QUADRATURE ROUTINE BASED ON THE TRAPEZOIDAL RULE.
C         USEFUL FOR INPUT NOISY PROFILES.
C
C**********************************************************************
C
C KEY TO FORTRAN IDENTIFIERS
C
C**********************************************************************
C
C INPUT QUANTITIES
C
C KM      NUMBER OF SAMPLES PER VIEW.
C LM      NUMBER OF VIEWS.
C SWID    WIDTH OF PROFILE.
C TWID    RANGE OF XPRIME (IN RADIANS).
C PROJ    ARRAY PROJ(KM,LM) CONTAINS PROJECTION DATA.
C DRL     ARRAY DRL(LM) CONTAINS THE DRIFT LENGTH FROM THE
C         REFERENCE PLANE TO THE LM STATIONS.  EMITTANCE DISTRIBUTION
C         WILL BE RECONSTRUCTED AT THE REFERENCE PLANE.
C DS      DISTANCE BETWEEN ADJACENT SAMPLES.
C SFID    ARRAY SFID(LM) CONTAINS THE POSITION OF THE AXIS OF ROTATION
C         PROJECTED ON EACH VIEW.
C LNOR    OTHER VIEWS WILL BE RENORMALIZED TO AGREE WITH THE
C         NORMALIZATION OF THE LNORTH VIEW.
C IM
C JM      IM, JM DEFINE SIZE OF GRID FOR RECONSTRUCTION: SOURCE(IM,JM).
C XGRID
C YGRID   ARRAYS XGRID AND YGRID DEFINE THE GRID FOR THE RECONSTRUCTION.
C         SOURCE(IM,JM) WILL BE COMPUTED AT (X,XPRIME) VALUES SPECIFIED
C         IN XGRID, YGRID.
C KTYPE   CODE WILL DO TEST PROBLEM FOR KTYPE=1,6.
C         CODE WILL PROCESS DATA ON FILE MENTIN IF KTYPE=0.
C KADJ    IF KADJ=0, SREF IS SET EQUAL TO SFID.  OTHERWISE EACH PROFILE
C         IS SHIFTED SO THAT THE CENTROID OF THE PROJECTION AGREES WITH
C         THE PROJECTION OF THE CENTROID.  IF KADJ=2, THE
C         RECONSTRUCTION WILL BE CENTERED AT THE ORIGIN.
C MITER   MAXIMUM NUMBER OF ITERATIONS IN SUBROUTINE MENT.
C PREC    DESIRED CONVERGENCE ACCURACY IN MATCHING INPUT DATA IN
C         ARRAY PROJ.
C QTOL    ALLOWS TOLERANCING IN MATCHING INPUT DATA IN ARRAY PROJ.
C
C**********************************************************************
C
C INTERMEDIATE QUANTITIES
C
C SCEN    ARRAY SCEN(LM) CONTAINS THE CENTROIDS OF THE PROFILES.
C SREF    ARRAY SREF(LM) CONTAINS THE POSITION OF THE PROJECTION OF THE
C         CENTER OF ROTATION.  IF KADJ=0, SREF IS SET EQUAL TO THE INPUT
C         SFID VALUES.  OTHERWISE EACH PROFILE IS SHIFTED SO THAT THE
C         CENTROID OF THE PROJECTION AGREES WITH THE PROJECTION OF THE
C         CENTROID.
C XCEN
C YCEN    XCEN, YCEN GIVE THE POSITION OF THE CENTROID OF THE 2-D
C         EMITTANCE FUNCTION.
C ROMA    ARRAY ROMA(4,4,LM) CONTAINS THE TRANSFER MATRICES FOR
C         THE LM STATIONS RELATIVE TO THE REFERENCE PLANE.  USER
C         MUST MODIFY SUBROUTINES SETP AND PREP IF THE TRANSFER
C         MATRICES ARE NOT PURE DRIFTS.
C HFAC    ARRAY HFAC(KM,LM) IS COMPUTED ITERATIVELY IN MENT.  THE
C         RECONSTRUCTED DENSITY FUNCTION IS A PRODUCT OF BACKPROJECTED
C         HFAC VALUES.
C
C**********************************************************************
C
C OUTPUT QUANTITIES
C
C ICON    NUMBER OF ITERATIONS NEEDED BY MENT
C QMAX    LARGEST RELATIVE ERROR IN MATCHING INPUT DATA IN PROJ ARRAY.
C TIME    CPU TIME IN SECONDS USED BY MENT SUBROUTINE.
C SOURCE  SOURCE(IM,JM) CONTAINS THE RECONSTRUCTED EMITTANCE FUNCTION
C         ON RECTANGULAR GRID SPECIFIED BY ARRAYS XGRID, YGRID.
C         THIS ARRAY IS ALSO WRITTEN OUT TO FILE RECON.
C
C**********************************************************************
C
      PROGRAM MENT2AC
      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN
      CHARACTER*80 NAME
      COMMON SPL(51),CONT(51),PFIT(51,20)
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
      COMMON /CONTI/ HFACO(51,20), CONTF
      LOGICAL CONTF
      COMMON / TYWID/ YSHIF, TWID
      COMMON /TIMDSP/ ITDFLAG
      COMMON /COLTAG/ COLOR, XSCAL, YSCAL, XOFF, YOFF, CHSIZE, NDEV
      LOGICAL         COLOR 
      CHARACTER*1 ANS
C
      WRITE(6,908)
    1 WRITE(6,910)
      READ(5,909,ERR=1,END=999) KTYPE
      IF (KTYPE .EQ. 0) THEN
       CALL READP
       ITDFLAG = 0	! IN TIMDS TAKE TIME AND DATE FROM SYMBOLS (IF ANY)
      ELSE
       CALL SETP
       ITDFLAG = 1	! IN TIMDS TAKE CURRENT TIME AND DATE
      ENDIF
      CALL PREP
C
    3 WRITE(6,911)
      READ(5,909,ERR=3,END=999) NDEV
      IF (NDEV .EQ. 0) NDEV = 1
      IF ((NDEV .LT. 1) .OR. (NDEV .GT. 4)) GO TO 3
      IF ((NDEV .EQ. 1) .OR. (NDEV .EQ. 3)) COLOR = .FALSE.
      IF ((NDEV .EQ. 2) .OR. (NDEV .EQ. 4)) COLOR = .TRUE.
C
      WRITE(6,1007) MITER
      READ(5,909,ERR=3,END=999) IPAR
      IF (IPAR .NE. 0) MITER = IPAR
      OPEN(UNIT=7,FILE='MENTOUT.DAT',STATUS='UNKNOWN')
      REWIND (UNIT=7)
      WRITE(7,901)NAME
      WRITE(7,902)SLIM,TLIM,XCEN,YCEN
      WRITE(7,903)(SCEN(L),L=1,LM)
      WRITE(7,905)(SREF(L),L=1,LM)
      WRITE(7,904)
    2 WRITE(6,901) NAME
      CALL TIMING(ITIM1)
      CALL MENT(ICON,QMAX)
      CALL TIMING(ITIM2)
      TIME=ITIM2-ITIM1
      WRITE(7,906)MITER,PREC,QTOL
      WRITE(7,907)ICON,QMAX,TIME
      CALL SPLOT
C
      WRITE(6,1000)
      READ(5,1001,END=999) ANS
      IF ( ANS.EQ.'Y' .OR. ANS.EQ.'y') THEN
       OPEN(UNIT=8, FILE='HFAC.DAT', STATUS='UNKNOWN')
       REWIND(UNIT=8)
       WRITE(8,1002) LM, NAME
       WRITE(8,1003) ( ( HFACO(K,L), K = 1, KM ), L = 1, LM )
       CLOSE(UNIT=8)
      ENDIF
C
      WRITE(6,1004)
      READ(5,1001,END=999) ANS
      IF (ANS.EQ.'Y' .OR. ANS.EQ.'y' .OR. ANS.EQ.' ') THEN
       WRITE(6,1005) TWID
       READ(5,1006,END=999) PAR
       IF (PAR.NE.0.0 .AND. PAR.NE.TWID) THEN
        TWID = PAR
        TLIM = .5 * TWID
        WRITE(7,902) SLIM, TLIM, XCEN, YCEN
        YLIM = TLIM
        DY = 2. * YLIM / FLOAT(JM - 1)
        DO J = 1, JM
         YGRID(J) = FLOAT(J - 1) * DY - YLIM + YSHIF
        ENDDO
        CALL PREP2
       ENDIF
       GO TO 2
      ENDIF
C
C      DO 91 L=1,LM
C      WRITE(7,991)
C      WRITE(7,990) L
C      IF(KTYPE.EQ.0) WRITE(7,993)(PROJ(K,L),K=1,KM),(PFIT(K,L),K=1,KM)
C      IF(KTYPE.NE.0) WRITE(7,994)(PROJ(K,L),K=1,KM),(PFIT(K,L),K=1,KM)
C   91 CONTINUE
C      WRITE(7,991)
C
      CLOSE(UNIT=7)
  999 CALL EXIT(0)
C
  901 FORMAT(/,1X,A80)
  902 FORMAT(/,' SLIM = ',1PE9.2,4X,'TLIM = ',1PE9.2,4X,
     1 'XCEN = ',1PE9.2,4X,'YCEN = ',1PE9.2)
  903 FORMAT(1X,'SCEN: ',1P10E9.2)
  904 FORMAT(1H )
  905 FORMAT(1X,'SREF: ',1P10E9.2)
  906 FORMAT(/,1X,'MITER = ',I5,5X,'PREC = ',F10.3,5X,'QTOL = ',
     1 F10.3)
  907 FORMAT(
     1' ICON  = ',I5,5X,'QAVD = ',E10.3,5X,'Time = ',F10.3/)
  908 FORMAT(' Test_numbers:'/
     1' 1: Off-center solid cylinder'/
     2' 2: Off-center solid cylinder             (with noisy data)'/
     3' 3: Solid cylinder inside hollow cylinder'/
     4' 4: Solid cylinder inside hollow cylinder (with noisy data)'/
     5' 5: Off-center tilted asymmetric gaussian'/
     6' 6: Off-center tilted asymmetric gaussian (with noisy data)')
  909 FORMAT(I2)
  910 FORMAT(' Enter test_number (1:6) or RET for measured data ',$)
  911 FORMAT(' Choose printer device (RET for 1):'/
     1' 1: Remote post script printer in black and white'/
     2' 2: Remote post script printer in color'/
     3' 3: Local printer in black and white'/
     4' 4: Local printer in color  ',$)
  990 FORMAT(' *** L =',I2,' ***')
  991 FORMAT('
     X**************************************************
     X*******************')
  993 FORMAT(5(10F7.0/),F7.0)
  994 FORMAT(5(10F7.4/),F7.4)
 1000 FORMAT(
     *' Do you want to store HFAC for a next run ? [Y/N] (Def=N) ',$)
 1001 FORMAT(A1)
 1002 FORMAT(I3,A80)
 1003 FORMAT(7(7E11.3/),2E11.3)
 1004 FORMAT(
     *' Do you want to continue the iteration ? [Y/N] (Def=Y) ',$)
 1005 FORMAT(' Enter new TWID (D =',F6.3,' rad) ',$)
 1006 FORMAT(F6.3)
 1007 FORMAT(' Enter maximum number of iterations (D =',I2,') ',$) 
      END

      FUNCTION ERFI(Z)
      DATA NITM/100/, TEST/1.E-12/
      X=Z
      IF(X.LT.0. .OR. X.GT.1. ) GOTO6
      IF(X.EQ.1.) GOTO9
      Y=0.
      DO 1 NIT=1,NITM
      XA=X+ EXP(X*X)* (Z- ERF(X)) *.8862269
C NOTE TEST NEVER SATISFIED ON NIT=1 SINCE Y=0.
      T1=   ((XA-Y)/XA)
      IF(T1.LT.TEST) GOTO2
 3    Y=XA
      X=Y
    1 CONTINUE
      PRINT8
 8    FORMAT(//' ERFI unable to converge, result =  neg indefinite '/)
      STOP
 6    PRINT7
 7    FORMAT(//' ERFI called with Y < 0 or Y > 1, result =  neg inde
     Xfinite '/)
      STOP
 9    ERFI=5.5
      RETURN
 2    ERFI=XA
      RETURN
      END

      FUNCTION HINT(S,L)
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
C
      IF (ABS(S).GT.SLIM) THEN
       HINT=0.
      ELSE
       SL=S+SREF(L)
       RA=SL*REDS
       K1=INT(RA)+1
       IF (RA.LT.0.) K1=K1-1
       K2=K1+1
       T1=RA-FLOAT(K1-1)
C
       IF (K1.GE.1 .AND. K1.LE.KM) THEN
        H1=HFAC(K1,L)
       ELSE
        H1=0.
       ENDIF
C
       IF (K2.GE.1 .AND. K2.LE.KM) THEN
        H2=HFAC(K2,L)
       ELSE
        H2=0.
       ENDIF
C
       HINT=H1+T1*(H2-H1)
      ENDIF
      RETURN
      END

      SUBROUTINE MENT(ICON,QMAX)
      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN
      CHARACTER*80 NAME
      COMMON SPL(51),CONT(51),PFIT(51,20)
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
      COMMON / PINT / S1,T1,L1,PA(20,20),PB(20,20)
      COMMON /CONTI/ HFACO(51,20), CONTF
      LOGICAL CONTF
      DIMENSION KINF(51)
      EXTERNAL QTRAP
      EXTERNAL PROD
      REAL QTRAP, PROD
c
      DATA EPSIL / 1.E-20 /
      DATA RELER / 5.E-03 /
c      DATA MAXEV / 1000 /
      TH=STRATN
      RATLO=1.-QTOL
      RATHI=1.+QTOL
      OMEGA=1./EPSIL
      QOLD=10.*OMEGA
C
      DO 701 ITER=1,MITER
C      K=LIB$MOVC3(4080,HFAC,HFACO)  !  HFACO=HFAC
      CALL UCOPY(HFAC,HFACO,1020)
      RELER=AMIN1(RELABN,RELRAN*QOLD)
      ICON=ITER
      QMAX=0.
      NZER=0
      NIND=0
      NINF=0
      NOUT=0
      N=0
C
      DO 602 L1=1,LM
      NKINF=0
      DO 601 K=1,KM
      S1=FLOAT(K-1)*DS-SREF(L1)
      IF (ABS(S1).GT.SLIM) GO TO 501
      TSUP=TLIM
      TINF=-TLIM
      SUM=QTRAP(PROD,TINF,TSUP,KM)
      PRKL=PROJ(K,L1)
      HOLD=HFAC(K,L1)
      POLD=HOLD*SUM
      PFIT(K,L1)=POLD
      IF (PRKL.GT.EPSIL) GO TO 503
      IF (POLD.GT.EPSIL) GO TO 502
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      NIND=NIND+1
      HNEW=HOLD*PRKL/(POLD+EPSIL)
      GO TO 505
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  501 CONTINUE
      NOUT=NOUT+1
      HNEW=0.
      GO TO 505
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  502 CONTINUE
      NZER=NZER+1
      HNEW=HOLD*PRKL/(POLD+EPSIL)
      GO TO 505
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  503 CONTINUE
      IF (POLD.GT.EPSIL) GO TO 504
      NINF=NINF+1
      NKINF=NKINF+1
      KINF(NKINF)=K
      HNEW=0.
      GO TO 505
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  504 CONTINUE
      RATIO=POLD/(PRKL+EPSIL)
      HNEW=HOLD
      IF (RATIO.LT.RATLO) HNEW=HOLD*RATLO/RATIO
      IF (RATIO.GT.RATHI) HNEW=HOLD*RATHI/RATIO
      Q=ABS(RATIO-1.)
      QMAX=QMAX+Q*Q
      N=N+1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  505 CONTINUE
      IF (HNEW .GT. 1.E+7) HNEW=0.
      HFAC(K,L1)=HNEW
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  506 CONTINUE
  601 CONTINUE
      IF (NKINF .NE. 0) THEN
       NNN=  MIN(15,NKINF)
       NNNN= MIN(30,NKINF)
       NNNNN=MIN(45,NKINF)
       WRITE(7,998) L1, (KINF(K), K=1, NNN)
       IF (NKINF.GT.15) WRITE(7,998) L1, (KINF(K), K=16,NNNN)
       IF (NKINF.GT.30) WRITE(7,998) L1, (KINF(K), K=31,NNNNN)
       IF (NKINF.GT.45) WRITE(7,998) L1, (KINF(K), K=46,NKINF)
      ENDIF
  602 CONTINUE
      QMAX=SQRT(QMAX/FLOAT(N))
      WRITE(6,999)ITER,QMAX,NINF,NIND,NZER,NOUT,N
      WRITE(7,999)ITER,QMAX,NINF,NIND,NZER,NOUT,N
      IF (QMAX.LE.PREC) GO TO 702
      IF (QMAX.LT.QOLD) GO TO 700
C      K=LIB$MOVC3(4080,HFACO,HFAC)  !  HFAC=HFACO
      CALL UCOPY(HFACO,HFAC,1020)
      QMAX=QOLD
      GO TO 702
  700 QOLD=QMAX
  701 CONTINUE
  702 CONTINUE
C
      DO 803 I=1,IM
      X=XGRID(I)
      DO 802 J=1,JM
      Y=YGRID(J)
      PRH=1.
      DO 801 L=1,LM
      S=X*ROMA(1,1,L)+Y*ROMA(1,2,L)
      PRH=PRH*HINT(S,L)
  801 CONTINUE
      SOURCE(I,J)=PRH
  802 CONTINUE
  803 CONTINUE
      RETURN
  998 FORMAT(' HFAC infinite   L   = ',I3,'; K   = ',I2,14(',',I2))
  999 FORMAT(' ITER= ',I2,', QAVD= ',1PE9.2,', NINF= ',I3,
     1 ', NIND= ',I3,', NZER= ',I3,', NOUT= ',I3,', N= ',I3)
      END

      SUBROUTINE PREP
      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN
      CHARACTER*80 NAME
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
      COMMON / PINT / S1,T1,L1,PA(20,20),PB(20,20)
C
      DIMENSION    BACK(20)
      CHARACTER*80 NAMEF
      CHARACTER*1  ANSWER
C
      DATA EPSIL / 1.E-20 /
      DATA BACK / 20*0. /
C                       MAKE PROJECTION DATA NON-NEGATIVE
      DO 12 L=1,LM
       DO 11 K=1,KM
        PROJ(K,L)=PROJ(K,L)-BACK(L)
        PROJ(K,L)=AMAX1(PROJ(K,L),0.)
   11  CONTINUE
   12 CONTINUE
C			AUTOMATIC NOISE REDUCTION
      WRITE(6,2000)
 2000 FORMAT(' Automatic noise reduction [Y/N] ? (Def = Y) ',$)
      READ(5,2001) ANSWER
 2001 FORMAT(A1)
      IF (ANSWER.EQ.' ' .OR. ANSWER.EQ.'Y' .OR. ANSWER.EQ.'y')
     * CALL NOISERED
C                       RENORMALIZE PROJECTION DATA AND COMPUTE CENTROID
      SUMN=0.
      ADDN=0.
      DO 13 K=1,KM
       TRAP=1.
       IF(K.EQ.1.OR.K.EQ.KM)TRAP=.5
       P=PROJ(K,LNOR)
       SUMN=SUMN+P*TRAP
       ADDN=ADDN+P*DS*FLOAT(K-1)*TRAP
   13 CONTINUE
      SCEN(LNOR)=ADDN/SUMN
C
      DO 17 L=1,LM
       IF (L.EQ.LNOR) GO TO 16
       SUML=0.
       ADDL=0.
       DO 14 K=1,KM
        TRAP=1.
        IF (K.EQ.1 .OR. K.EQ.KM) TRAP=.5
        P=PROJ(K,L)
        SUML=SUML+P*TRAP
   14  CONTINUE
       RATL=SUMN/SUML
C
       DO 15 K=1,KM
        TRAP=1.
        IF (K.EQ.1 .OR. K.EQ.KM) TRAP=.5
        P=RATL*PROJ(K,L)
        PROJ(K,L)=P
        ADDL=ADDL+P*DS*FLOAT(K-1)*TRAP
   15  CONTINUE
       SCEN(L)=ADDL/SUMN
   16  CONTINUE
   17 CONTINUE
C                       COMPUTE INVERSE OF TRANSFER MATRIX
      DO 18 L=1,LM
       DETR=ROMA(1,1,L)*ROMA(2,2,L)-ROMA(1,2,L)*ROMA(2,1,L)
       DENR=1./DETR
       RINV(1,1,L)=ROMA(2,2,L)*DENR
       RINV(2,2,L)=ROMA(1,1,L)*DENR
       RINV(1,2,L)=-ROMA(1,2,L)*DENR
       RINV(2,1,L)=-ROMA(2,1,L)*DENR
   18 CONTINUE
C                       COMPUTE COEFFICENTS FOR FUNCTION PROD
      DO 118 I=1,LM
       DO 117 J=1,LM
        PA(I,J)=ROMA(1,1,I)*RINV(1,1,J)+ROMA(1,2,I)*RINV(2,1,J)
  117   PB(I,J)=ROMA(1,1,I)*RINV(1,2,J)+ROMA(1,2,I)*RINV(2,2,J)
  118 CONTINUE
C                       COMPUTE XCEN, YCEN
      TT1=0.
      TT2=0.
      TT3=0.
      SS1=0.
      SS2=0.
      DO 19 L=1,LM
      CP=ROMA(1,1,L)
      SP=ROMA(1,2,L)
      TT1=TT1+CP*CP
      TT2=TT2+SP*SP
      TT3=TT3+CP*SP
      SREL=SCEN(L)-SFID(L)
      SS1=SS1+CP*SREL
      SS2=SS2+SP*SREL
   19 CONTINUE
      DET=TT1*TT2-TT3*TT3+EPSIL
      XCEN=(TT2*SS1-TT3*SS2)/DET
      YCEN=(TT1*SS2-TT3*SS1)/DET
      IF(KADJ.EQ.0)GO TO 21
      IF(KADJ.EQ.2)GO TO 23
C                       COMPUTE SREF
      DO 20 L=1,LM
      SADJ=XCEN*ROMA(1,1,L)+YCEN*ROMA(1,2,L)-SCEN(L)+SFID(L)
      SREF(L)=SFID(L)-SADJ
   20 CONTINUE
      GO TO 25
C                       NO CORRECTION IF KADJ=0
   21 CONTINUE
      DO 22 L=1,LM
      SREF(L)=SFID(L)
   22 CONTINUE
      GO TO 25
C                       CENTROID AT ORIGIN IF KADJ=2
   23 CONTINUE
      DO 24 L=1,LM
      SREF(L)=SCEN(L)
   24 CONTINUE
   25 CONTINUE
C
      ENTRY PREP2	! INITIALIZE HFAC
C
      WRITE(6,1000)
      READ(5,1001,ERR=31) ANSWER
      IF ( ANSWER .NE. 'F' ) GO TO 31
      OPEN(UNIT=8,FILE='HFAC.DAT',STATUS='OLD',ERR=30)
      READ(8,1002) LMF,NAMEF
      IF (NAMEF .NE. NAME ) GO TO 30
      IF ( LMF .NE. LM ) GO TO 30
      READ(8,1003) ( ( HFAC(K,L), K = 1, KM ), L = 1, LM )
      CLOSE(UNIT=8)
      GO TO 34
   30 CLOSE(UNIT=8)
      WRITE(6,1004)
   31 DO 33 L=1,LM
      DO 32 K=1,KM
      HFAC(K,L)=1.
   32 CONTINUE
   33 CONTINUE
   34 RETURN
 1000 FORMAT(' Enter F for HFAC from file, RET for internal values ',$)
 1001 FORMAT(A4)
 1002 FORMAT(I3,A80)
 1003 FORMAT(7(7E11.3/),2E11.3)
 1004 FORMAT(' HFAC.DAT not found, taking internal values.')
      END

      SUBROUTINE NOISERED
C
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
C
      DO 100 L = 1, LM
C
C     FIRST FIND MAXIMUM OF PROFILE
C
       MAX = 0
       DO 10 K = 1, KM
        IF (PROJ(K,L) .GT. MAX) THEN
         MAX  = PROJ(K,L)
         IPOS = K
        ENDIF
   10  CONTINUE
C
C      ZERO NOISE TO THE LEFT
C
       DO 30 K = 2, IPOS
        IF (PROJ(K,L) .EQ. 0) THEN
         DO 20 J = 1, K
          PROJ(J,L) = 0
   20    CONTINUE
        ENDIF
   30  CONTINUE
C
C      ZERO NOISE TO THE RIGHT
C
       DO 50 K = KM-1, IPOS, -1
        IF (PROJ(K,L) .EQ. 0) THEN
         DO 40 J =  K, KM
          PROJ(J,L) = 0
   40    CONTINUE
        ENDIF
   50  CONTINUE
C
  100 CONTINUE		! FOR EACH PROFILE
C
      RETURN
      END

      REAL FUNCTION PROD(T)
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
      COMMON / PINT / S1,T1,L1,PA(20,20),PB(20,20)
c
      T1=T
      PRH=1.
      DO 302 L2=1,LM
       IF(L2.NE.L1) THEN
        S2=S1*PA(L2,L1)+T1*PB(L2,L1)
        PRH=PRH*HINT(S2,L2)
       ENDIF
  302 CONTINUE
      PROD=PRH
      RETURN
      END

      REAL FUNCTION QTRAP(FUNC,XLO,XHI,NM)
C
      EXTERNAL FUNC
c
      DX=(XHI-XLO)/FLOAT(NM-1)
      SUM=0.
      X=XLO
      DO 101 N=1,NM
       SUM=SUM+FUNC(X)
       X=X+DX
  101 CONTINUE
      QTRAP=SUM*DX
c
      RETURN
      END

      REAL FUNCTION RANFF(ARG)
c
      LOGICAL FIRST
      DATA FIRST /.TRUE./
c
      IF (FIRST) THEN
       FIRST=.FALSE.
       CALL SEED(INT(ARG))
      ENDIF
c
      CALL RANDOM(RAN)
      RANFF=RAN
c
      RETURN
      END

      SUBROUTINE READP

      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN
      CHARACTER*80 NAME
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
      COMMON / TYWID/ YSHIF, TWID
      CHARACTER*15 FILEN
C
      DATA KFILE / 1 /
      DATA FILEN /'MENTIN.DAT'/
C
      KM   = 51
      LNOR = 1
C
c    1 WRITE(6,1000)
c 1000 FORMAT(' Enter version number of MENTIN.DAT (Def = highest) ',$)
c      READ(5,1001) IVERS
c 1001 FORMAT(I4)
c      WRITE(FILEN(12:15),1001) IVERS
c      IF (IVERS .EQ. 0) FILEN(12:15) = '    '
c
      OPEN(UNIT=9,FILE=FILEN,STATUS='OLD',ERR=5)
      GO TO 10	
    5 WRITE(6,*) 'Sorry, file not existing'
      CALL EXIT(0)
C
   10 DO 602 KF=1,KFILE
       READ(9,901) NAME
       READ(9,902) XSHIF,SWID,YSHIF,TWID,LM
       DO 601 L=1,LM
        READ(9,903)((ROMA(J,K,L),K=1,2),J=1,2)
        READ(9,904)(PROJ(K,L),K=1,KM)
  601  CONTINUE
       READ(9,905)KADJ,MITER,PREC,QTOL,STEPAT,RELABN,RELRAN,STRATN
  602 CONTINUE
      CLOSE(UNIT=9)
C
  901 FORMAT(A)
  902 FORMAT(4F10.3,I6)
  903 FORMAT(4F10.3)
  904 FORMAT(10F7.0)
  905 FORMAT(2I5,6F10.3)
C 
      SLIM=.5*SWID
      TLIM=.5*TWID
      DS=2.*SLIM/FLOAT(KM-1)
      REDS=1./DS
      DO 501 L=1,LM
      SFID(L)=SLIM
C     ROMA(1,1,L)=1.
C     ROMA(1,2,L)=DRL(L)
C     CONVERSION FROM CM IN M
      ROMA(1,2,L)=100.*ROMA(1,2,L)
C     ROMA(2,1,L)=0.
C     CONVERSION FROM CM IN M
      ROMA(2,1,L)=0.01*ROMA(2,1,L)
C     ROMA(2,2,L)=1.
  501 CONTINUE
      IM=51
      JM=51
      XLIM=SLIM
      YLIM=TLIM
      DX=2.*XLIM/FLOAT(IM-1)
      DY=2.*YLIM/FLOAT(JM-1)
      DO 701 I=1,IM
      XGRID(I)=FLOAT(I-1)*DX-XLIM+XSHIF
  701 CONTINUE
      DO 702 J=1,JM
      YGRID(J)=FLOAT(J-1)*DY-YLIM+YSHIF
  702 CONTINUE
      RETURN
      END

      SUBROUTINE SETP
c
      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN

      CHARACTER*80 NAME
c
      COMMON / EXPD / KM,LM,PROJ(51,20),DRL(20),DS,REDS,SFID(20),LNOR
      COMMON / TRAN / IM,JM,XGRID(51),YGRID(51),SOURCE(51,51)
      COMMON / STOR / XCEN,YCEN,SCEN(20),ROMA(2,2,20),RINV(2,2,20),
     1 HFAC(51,20),SREF(20),SLIM,TLIM
c
      DATA ZERO / 1. /
      DATA BETA / .05 /
c
      NAME = ' '
      KADJ=0
      MITER=9
      PREC=1.E-02
      QTOL=5.E-03
      STEPAT=-.5
      RELABN=.05
      RELRAN=.1
      STRATN=0.
      KM=51
      LM=3
      SLIM=.5
      TLIM=.5
      DS=2.*SLIM/FLOAT(KM-1)
      REDS=1./DS
      LNOR=1
      DRL(1)=-1.
      DRL(2)=0.
      DRL(3)=1.
      DO 501 L=1,LM
      SFID(L)=SLIM
      ROMA(1,1,L)=1.
      ROMA(1,2,L)=DRL(L)
      ROMA(2,1,L)=0.
      ROMA(2,2,L)=1.
      RINV(1,1,L)=ROMA(2,2,L)
      RINV(2,2,L)=ROMA(1,1,L)
      RINV(1,2,L)=-ROMA(1,2,L)
      RINV(2,1,L)=-ROMA(2,1,L)
  501 CONTINUE
      NM=5*KM
      DT=TLIM/FLOAT(NM)
      NMTP1=2*NM+1
      DO 305 L=1,LM
      DO 304 K=1,KM
      S=FLOAT(K-1)*DS-SFID(L)
      IF(ABS(S).GT.SLIM)GO TO 303
      SUM=0.
      DO 302 N=1,NMTP1
      T=FLOAT(N-NM-1)*DT
      IF(ABS(T).GT.TLIM)GO TO 301
      X=S*RINV(1,1,L)+T*RINV(1,2,L)
      Y=S*RINV(2,1,L)+T*RINV(2,2,L)
      SOF=SOFUN(X,Y)
      SUM=SUM+SOF
      IF(N.EQ.1.OR.N.EQ.NMTP1)SUM=SUM-.5*SOF
  301 CONTINUE
  302 CONTINUE
      PROJ(K,L)=SUM*DT
  303 CONTINUE
  304 CONTINUE
  305 CONTINUE
      IM=51
      JM=51
      XLIM=.5
      YLIM=.5
      DX=2.*XLIM/FLOAT(IM-1)
      DY=2.*YLIM/FLOAT(JM-1)
      DO 701 I=1,IM
      XGRID(I)=FLOAT(I-1)*DX-XLIM
  701 CONTINUE
      DO 702 J=1,JM
      YGRID(J)=FLOAT(J-1)*DY-YLIM
  702 CONTINUE
      DO 802 I=1,IM
      X=XGRID(I)
      DO 801 J=1,JM
      Y=YGRID(J)
      SOURCE(I,J)=SOFUN(X,Y)
  801 CONTINUE
  802 CONTINUE
      IF(MOD(KTYPE,2).EQ.1)GO TO 903
      NAME(41:57) = '(with noisy data)'
      DO 902 L=1,LM
      DO 901 K=1,KM
      U1=RANFF(ZERO)
      U2=RANFF(ZERO)
      U3=SIGN(1.,U2-.5)*ERFI(U1)
      PROJ(K,L)=PROJ(K,L)*(1.+BETA*U3)
  901 CONTINUE
  902 CONTINUE
  903 CONTINUE
      RETURN
      END

      FUNCTION SOFUN(X,Y)
c
      COMMON / TROL / NAME,KTYPE,KADJ,MITER,PREC,QTOL,
     1 STEPAT,RELABN,RELRAN,STRATN

      CHARACTER*80 NAME
c
      GO TO (1001,1001,1002,1002,1003,1003,1004,1004,1005,1005) KTYPE
c
 1001 CONTINUE
      NAME = 'Off-center solid cylinder'
      X0=.05
      Y0=0.
      R0=.25
      XR=X-X0
      YR=Y-Y0
      SOFUN=0.
      IF ((XR*XR+YR*YR).LE.R0*R0) SOFUN=1.
      IF (KTYPE.EQ.2) GO TO 2001
      RETURN

 1002 CONTINUE
      NAME = 'Solid cylinder inside hollow cylinder'
      X2=-.05
      Y2=.02
      R2=.15
      V2=1.
      X3=0.
      Y3=0.
      R3=.25
      R4=.3
      V3=.5
      SOFUN=0.
      XD=X-X2
      YD=Y-Y2
      IF ((XD*XD+YD*YD).LE.R2*R2) SOFUN=V2
      XD=X-X3
      YD=Y-Y3
      SD=XD*XD+YD*YD
      IF (SD.GE.R3*R3.AND.SD.LE.R4*R4) SOFUN=V3
      IF (KTYPE.EQ.4) GO TO 2001
      RETURN

 1003 CONTINUE
      NAME = 'Off-center tilted asymmetric Gaussian'
      XG=.02
      YG=0.
      XD=X-XG
      YD=Y-YG
      ARG=6.0*(9.*(XD*XD+YD*YD)+6.*XD*YD)
      SOFUN=EXP(-ARG)
      IF (KTYPE.EQ.6) GO TO 2001
      RETURN

 1004 CONTINUE
      IF (KTYPE.EQ.8) GO TO 2001
      RETURN

 1005 CONTINUE
      IF (KTYPE.EQ.10) GO TO 2001
      RETURN

 2001 CONTINUE
      RETURN
      END

      SUBROUTINE UCOPY(A,B,N)
C
      REAL A(1), B(1)
C
      DO 10 I = 1, N
   10 B(I) = A(I)
C
      RETURN
      END








